import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import NodeClam from 'node-clamav';
import winston from 'winston';
import { config } from '../config/environment.js';

// Configure Winston logger for malware scanning
const logger = winston.createLogger({
  level: config.logging.level,
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ 
      filename: './logs/malware-scan.log',
      maxsize: config.logging.maxSize,
      maxFiles: config.logging.maxFiles 
    }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// ClamAV configuration
const clamAVConfig = {
  host: config.clamav.host,
  port: config.clamav.port,
  timeout: config.clamav.timeout,
  remove_infected: false, // We'll handle quarantine manually
  quarantine_infected: false, // We'll handle quarantine manually
  scan_archives: true,
  scan_mail: true,
  scan_pe: true,
  scan_elf: true,
  scan_ole2: true,
  scan_pdf: true,
  scan_swf: true,
  scan_html: true,
  detect_pua: true,
  detect_broken: true,
  max_filesize: config.upload.maxFileSize,
  max_scansize: config.upload.maxFileSize * 2,
  max_files: 100,
  max_recursion: 10,
  max_dir: 15,
  debug: config.development.debug
};

// Initialize ClamAV with proper error handling
let clamscan = null;
let clamAVAvailable = false;

const initializeClamAVClient = async () => {
  try {
    clamscan = new NodeClam(clamAVConfig);
    clamAVAvailable = true;
    return true;
  } catch (error) {
    logger.warn('ClamAV initialization failed, malware scanning will be disabled:', error.message);
    clamAVAvailable = false;
    return false;
  }
};

// Initialize ClamAV client
initializeClamAVClient();

// Promisify filesystem operations
const mkdir = promisify(fs.mkdir);
const copyFile = promisify(fs.copyFile);
const unlink = promisify(fs.unlink);
const access = promisify(fs.access);

// Initialize ClamAV connection
let clamAVInitialized = false;

const initializeClamAV = async () => {
  if (clamAVInitialized) return true;
  
  if (!clamAVAvailable || !clamscan) {
    logger.warn('ClamAV client not available, skipping initialization');
    return false;
  }
  
  try {
    await clamscan.init();
    clamAVInitialized = true;
    logger.info('ClamAV initialized successfully');
    return true;
  } catch (error) {
    logger.error('Failed to initialize ClamAV:', error);
    clamAVAvailable = false;
    return false;
  }
};

// Check ClamAV service status
export const checkClamAVStatus = async () => {
  try {
    if (!clamAVAvailable || !clamscan) {
      return {
        status: 'disabled',
        message: 'ClamAV client not available',
        timestamp: new Date().toISOString()
      };
    }
    
    const version = await clamscan.getVersion();
    logger.info('ClamAV service is running', { version });
    return {
      status: 'healthy',
      version,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    logger.error('ClamAV service check failed:', error);
    clamAVAvailable = false;
    return {
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    };
  }
};

// Quarantine infected file
const quarantineFile = async (filePath, scanResult) => {
  try {
    // Create quarantine directory if it doesn't exist
    const quarantineDir = path.resolve(config.clamav.quarantineDir);
    await mkdir(quarantineDir, { recursive: true });
    
    // Generate quarantine filename with timestamp
    const originalName = path.basename(filePath);
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const quarantineName = `${timestamp}_${originalName}`;
    const quarantinePath = path.join(quarantineDir, quarantineName);
    
    // Copy file to quarantine
    await copyFile(filePath, quarantinePath);
    
    // Log quarantine action
    logger.warn('File quarantined', {
      originalPath: filePath,
      quarantinePath,
      threat: scanResult.virus,
      timestamp: new Date().toISOString()
    });
    
    // Remove original file
    await unlink(filePath);
    
    return {
      success: true,
      quarantinePath,
      threat: scanResult.virus
    };
  } catch (error) {
    logger.error('Failed to quarantine file:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

// Enhanced malware scanning function
export const scanFile = async (filePath, options = {}) => {
  const scanStartTime = Date.now();
  
  try {
    // Check if ClamAV is enabled
    if (!config.clamav.enabled) {
      logger.info('ClamAV scanning disabled, skipping scan', { filePath });
      return {
        isInfected: false,
        virus: null,
        skipped: true,
        reason: 'ClamAV disabled'
      };
    }
    
    // Initialize ClamAV if not already done
    if (!clamAVInitialized) {
      const initialized = await initializeClamAV();
      if (!initialized) {
        logger.error('ClamAV not available, allowing file upload', { filePath });
        return {
          isInfected: false,
          virus: null,
          skipped: true,
          reason: 'ClamAV unavailable'
        };
      }
    }
    
    // Check if file exists
    await access(filePath, fs.constants.F_OK);
    
    // Get file stats
    const stats = fs.statSync(filePath);
    const fileSize = stats.size;
    
    // Check file size limits
    if (fileSize > config.upload.maxFileSize) {
      logger.warn('File exceeds size limit for scanning', { filePath, fileSize });
      return {
        isInfected: false,
        virus: null,
        skipped: true,
        reason: 'File too large'
      };
    }
    
    // Perform scan
    logger.info('Starting malware scan', { filePath, fileSize });
    const scanResult = await clamscan.scanFile(filePath);
    
    const scanDuration = Date.now() - scanStartTime;
    
    // Log scan results
    logger.info('Malware scan completed', {
      filePath,
      isInfected: scanResult.isInfected,
      virus: scanResult.virus,
      scanDuration,
      fileSize
    });
    
    // Handle infected files
    if (scanResult.isInfected) {
      logger.error('MALWARE DETECTED', {
        filePath,
        threat: scanResult.virus,
        fileSize,
        scanDuration,
        clientInfo: options.clientInfo || 'unknown'
      });
      
      // Quarantine the file
      const quarantineResult = await quarantineFile(filePath, scanResult);
      
      // Send security alert if enabled
      if (config.notifications.securityAlertsEnabled) {
        await sendSecurityAlert('malware_detected', {
          filePath,
          threat: scanResult.virus,
          quarantined: quarantineResult.success,
          timestamp: new Date().toISOString()
        });
      }
      
      return {
        ...scanResult,
        quarantined: quarantineResult.success,
        quarantinePath: quarantineResult.quarantinePath,
        scanDuration
      };
    }
    
    return {
      ...scanResult,
      scanDuration
    };
    
  } catch (error) {
    const scanDuration = Date.now() - scanStartTime;
    logger.error('Malware scan failed', {
      filePath,
      error: error.message,
      scanDuration
    });
    
    // In case of scan failure, log but don't block upload in development
    if (config.env === 'development') {
      return {
        isInfected: false,
        virus: null,
        error: error.message,
        scanDuration
      };
    }
    
    // In production, treat scan failures as potential threats
    return {
      isInfected: true,
      virus: 'SCAN_FAILED',
      error: error.message,
      scanDuration
    };
  }
};

// Middleware for scanning uploaded files
export const scanUploadedFiles = async (req, res, next) => {
  try {
    // Skip if no files uploaded
    if (!req.files && !req.file) {
      return next();
    }
    
    const files = req.files ? Object.values(req.files).flat() : [req.file];
    const scanResults = [];
    
    // Scan each uploaded file
    for (const file of files) {
      if (!file || !file.path) continue;
      
      const scanResult = await scanFile(file.path, {
        clientInfo: {
          ip: req.ip,
          userAgent: req.get('User-Agent'),
          userId: req.user?.id || 'anonymous'
        }
      });
      
      scanResults.push({
        filename: file.filename || file.originalname,
        scanResult
      });
      
      // Block request if malware detected
      if (scanResult.isInfected) {
        logger.error('Upload blocked - malware detected', {
          filename: file.filename || file.originalname,
          threat: scanResult.virus,
          clientIp: req.ip,
          userId: req.user?.id || 'anonymous'
        });
        
        // Clean up remaining files
        await cleanupUploadedFiles(files);
        
        return res.status(400).json({
          success: false,
          message: 'File upload blocked - malware detected',
          error: 'MALWARE_DETECTED',
          details: {
            filename: file.filename || file.originalname,
            threat: scanResult.virus
          }
        });
      }
    }
    
    // Add scan results to request for logging
    req.malwareScanResults = scanResults;
    
    next();
  } catch (error) {
    logger.error('Malware scanning middleware error:', error);
    
    // In production, block uploads on scan errors
    if (config.env === 'production') {
      return res.status(500).json({
        success: false,
        message: 'File security scan failed',
        error: 'SCAN_ERROR'
      });
    }
    
    // In development, log and continue
    next();
  }
};

// Cleanup uploaded files
const cleanupUploadedFiles = async (files) => {
  for (const file of files) {
    if (file && file.path) {
      try {
        await unlink(file.path);
      } catch (error) {
        logger.error('Failed to cleanup file:', error);
      }
    }
  }
};

// Send security alert
const sendSecurityAlert = async (type, details) => {
  try {
    if (!config.notifications.securityAlertEmail) {
      return;
    }
    
    // This would integrate with your email service
    logger.info('Security alert sent', { type, details });
    
    // TODO: Implement email notification
    // await sendEmail({
    //   to: config.notifications.securityAlertEmail,
    //   subject: `Security Alert: ${type.toUpperCase()}`,
    //   body: JSON.stringify(details, null, 2)
    // });
    
  } catch (error) {
    logger.error('Failed to send security alert:', error);
  }
};

// Batch scan files in directory
export const scanDirectory = async (directoryPath, options = {}) => {
  try {
    const scanResult = await clamscan.scanDir(directoryPath);
    
    logger.info('Directory scan completed', {
      directoryPath,
      goodFiles: scanResult.goodFiles?.length || 0,
      badFiles: scanResult.badFiles?.length || 0,
      errors: scanResult.errors?.length || 0
    });
    
    return scanResult;
  } catch (error) {
    logger.error('Directory scan failed', { directoryPath, error: error.message });
    throw error;
  }
};

// Update virus definitions
export const updateVirusDefinitions = async () => {
  try {
    // This would typically be handled by freshclam daemon
    logger.info('Virus definitions update requested');
    return {
      success: true,
      message: 'Virus definitions update initiated'
    };
  } catch (error) {
    logger.error('Failed to update virus definitions:', error);
    return {
      success: false,
      error: error.message
    };
  }
};

// Get quarantine summary
export const getQuarantineSummary = async () => {
  try {
    const quarantineDir = path.resolve(config.clamav.quarantineDir);
    
    // Check if quarantine directory exists
    try {
      await access(quarantineDir, fs.constants.F_OK);
    } catch {
      return {
        totalFiles: 0,
        totalSize: 0,
        files: []
      };
    }
    
    const files = fs.readdirSync(quarantineDir);
    const quarantineFiles = [];
    let totalSize = 0;
    
    for (const file of files) {
      const filePath = path.join(quarantineDir, file);
      const stats = fs.statSync(filePath);
      
      quarantineFiles.push({
        filename: file,
        size: stats.size,
        quarantineDate: stats.mtime,
        path: filePath
      });
      
      totalSize += stats.size;
    }
    
    return {
      totalFiles: quarantineFiles.length,
      totalSize,
      files: quarantineFiles
    };
  } catch (error) {
    logger.error('Failed to get quarantine summary:', error);
    return {
      totalFiles: 0,
      totalSize: 0,
      files: [],
      error: error.message
    };
  }
};

// Health check endpoint data
export const getHealthStatus = async () => {
  const clamAVStatus = await checkClamAVStatus();
  const quarantineSummary = await getQuarantineSummary();
  
  return {
    clamav: clamAVStatus,
    quarantine: quarantineSummary,
    configuration: {
      enabled: config.clamav.enabled,
      host: config.clamav.host,
      port: config.clamav.port,
      timeout: config.clamav.timeout
    }
  };
};

export default {
  scanFile,
  scanUploadedFiles,
  scanDirectory,
  updateVirusDefinitions,
  getQuarantineSummary,
  getHealthStatus,
  checkClamAVStatus
};